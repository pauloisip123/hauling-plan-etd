<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Export Per Date - Full</title>
<script src="https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js"></script>

<style>
  body { font-family:'Segoe UI',sans-serif; background:#0a0b15; color:#e0e0e0; display:flex; justify-content:center; padding:18px; }
  .container { width:95%; max-width:1100px; background:#101126; padding:24px; border-radius:14px; box-shadow:0 12px 40px rgba(0,0,0,0.7); }
  h2 { text-align:center; color:#00ffd0; text-shadow:0 0 8px #00ffd0; margin-top:0; }
  label { display:block; margin-top:8px; color:#bfefff; }
  input[type="file"], input[type="date"] { width:100%; padding:10px; margin-top:6px; margin-bottom:6px; border-radius:8px; border:none; background:#1a1b2a; color:#e6f9ff; }
  .buttons { display:flex; gap:16px; margin-top:12px; }
  button { flex:1; padding:12px; border-radius:12px; border:none; font-weight:600; cursor:pointer; background:linear-gradient(135deg,#00ffd0,#0070ff); color:#04121a; box-shadow:0 6px 18px rgba(0,0,0,0.6); }
  button.running { animation: neonGlow 1.2s infinite alternate; }
  @keyframes neonGlow { 0%{ box-shadow:0 0 8px #00ffd0,0 0 18px #00ffd0 } 100%{ box-shadow:0 0 18px #00ffd0,0 0 36px #00ffd0 } }
  .progress-container { margin-top:12px; background:#1a1b2a; border-radius:10px; overflow:hidden; box-shadow: inset 0 0 10px rgba(0,0,0,0.5); }
  .progress-bar { height:20px; width:0%; background:linear-gradient(90deg,#00ffd0,#0070ff); text-align:center; color:#001; font-weight:700; transition:width 0.25s ease; }
  #logPanel { margin-top:14px; border-radius:10px; overflow:hidden; border:1px solid #18202a; box-shadow:0 8px 30px rgba(0,0,0,0.6); }
  #logTitle { background:#071127; color:#66f6ff; padding:8px 12px; font-weight:700; letter-spacing:0.6px; border-bottom:1px solid #0f2030; }
  #logOutput { background:#071127; color:#dff7ff; padding:12px; font-family:Consolas, "Courier New", monospace; white-space:pre-wrap; max-height:260px; overflow:auto; margin:0; }
  .logClickable { cursor:pointer; color:#00d5ff; text-decoration:underline; }
  .logClickable:hover { color:#7fffd4; }
  .note { margin-top:10px; color:#9fd9ff; font-size:13px; }

  /* ---- VTS BUTTON (ADD ONLY) ---- */
  .vts-btn {
    position: fixed;
    top: 14px;
    right: 18px;
    padding: 6px 14px;
    font-size: 12px;
    font-weight: 700;
    border-radius: 8px;
    background: linear-gradient(135deg,#00ffd0,#0070ff);
    color: #04121a;
    text-decoration: none;
    box-shadow: 0 4px 14px rgba(0,0,0,0.6);
    z-index: 9999;
  }
  .vts-btn:hover { opacity: 0.9; }
</style>
</head>

<body>

<!-- VTS BUTTON -->
<a class="vts-btn" href="https://pauloisip123.github.io/buyoff" target="_blank">
  VTS
</a>

<div class="container">
  <h2>ðŸš€ Export Per Date â€” MCLOGI</h2>

  <label>Upload Excel File</label>
  <input id="file" type="file" accept=".xls,.xlsx">

  <div style="display:flex;gap:12px;margin-top:8px;">
    <div style="flex:1">
      <label>Start Date</label>
      <input id="start" type="date">
    </div>
    <div style="flex:1">
      <label>End Date</label>
      <input id="end" type="date">
    </div>
  </div>

  <div class="buttons">
    <button id="run">Run</button>
    <button id="download" disabled>Download</button>
  </div>

  <div class="progress-container">
    <div id="progress-bar" class="progress-bar">0%</div>
  </div>

  <div id="logPanel">
    <div id="logTitle">LOG OUTPUT</div>
    <pre id="logOutput">Ready.</pre>
  </div>

  <div class="note">
    Note: Sheet names follow <code>MM_DD_YYYY</code>. Log shows <code>MM_DD_YYYY = batch / index14</code>.
  </div>
</div>

<script>
/* Globals */
const logEl = document.getElementById('logOutput');
const setLog = s => { logEl.innerHTML += '\n'+s; logEl.scrollTop = logEl.scrollHeight; };
const clearLog = () => { logEl.textContent = ''; };
let processedWB = null;
let storedSheets = {};

const setProgress = p => {
  const el = document.getElementById('progress-bar');
  el.style.width = p+'%';
  el.textContent = p+'%';
};

/* --- PARSE DATE FUNCTIONS --- */
const parseU = v => {
  if(v == null || v === '') return null;
  if(v instanceof Date) return v;
  if(typeof v === 'number'){
    const d = XLSX.SSF.parse_date_code(v);
    if(d) return new Date(d.y,d.m-1,d.d,d.H,d.M,d.S);
  }
  if(typeof v === 'string'){
    const s = v.trim();
    let m = s.match(/(\d{1,2})\/(\d{1,2})\/(\d{4})\s+(\d{1,2}):(\d{2})/);
    if(m) return new Date(m[3],m[1]-1,m[2],m[4],m[5]);
    m = s.match(/(\d{1,2})\/(\d{1,2})\/(\d{4})/);
    if(m) return new Date(m[3],m[1]-1,m[2]);
    const d = new Date(s);
    if(!isNaN(d)) return d;
  }
  return null;
};

const formatTextDate = dt => {
  if(!dt || isNaN(dt)) return '';
  const mm = String(dt.getMonth()+1).padStart(2,'0');
  const dd = String(dt.getDate()).padStart(2,'0');
  const yyyy = dt.getFullYear();
  const hh = String(dt.getHours()).padStart(2,'0');
  const mi = String(dt.getMinutes()).padStart(2,'0');
  return `${mm}/${dd}/${yyyy} ${hh}:${mi}`;
};

const forceDateText = v => {
  const d = parseU(v);
  if(!d || isNaN(d)) return v ?? '';
  return formatTextDate(d);
};

const makeSheetNameFromDate = dt => {
  const mm = String(dt.getMonth()+1).padStart(2,'0');
  const dd = String(dt.getDate()).padStart(2,'0');
  const yyyy = dt.getFullYear();
  return `${mm}_${dd}_${yyyy}`.slice(0,31);
};

/* ---------------------- RUN BUTTON ---------------------- */
document.getElementById('run').addEventListener('click', async () => {

  const fileInput = document.getElementById('file');
  const startVal = document.getElementById('start').value;
  const endVal = document.getElementById('end').value;

  if(!fileInput.files[0]) return alert('Select Excel file');
  if(!startVal || !endVal) return alert('Select start + end dates');

  const btnRun = document.getElementById('run');
  const btnDownload = document.getElementById('download');

  btnRun.disabled = true;
  btnRun.classList.add('running');
  btnRun.textContent = 'Processing...';
  btnDownload.disabled = true;

  clearLog();
  setLog('Reading file...');
  setProgress(0);

  try {
    const data = await fileInput.files[0].arrayBuffer();
    const wb = XLSX.read(data, { type:'array' });
    const ws = wb.Sheets[wb.SheetNames[0]];
    const rows = XLSX.utils.sheet_to_json(ws, { header:1, defval:'' });

    if(rows.length < 6) throw 'File needs â‰¥ 6 rows';

    const headers = rows.slice(0,4);
    const body = rows.slice(4);

    const colQ = 16;
    const colU = 20;

    let batchGroups = {};
    body.forEach(r=>{
      let bk = (r[colQ]||'').toString().trim();
      let rawU = r[colU];
      if(!batchGroups[bk]) batchGroups[bk]=[];
      batchGroups[bk].push({row:r,rawU});
    });

    const dateGroups = {};
    const sheetDates = {};

    const startDate = new Date(startVal+'T00:00:00');
    const endDate = new Date(endVal+'T23:59:59');

    let processed = 0;
    const keys = Object.keys(batchGroups);

    for(const batchKey of keys){
      const items = batchGroups[batchKey];
      const parsed = items.map(it=>({ ...it, dt:parseU(it.rawU) }))
                         .filter(p=>p.dt && !isNaN(p.dt));

      if(parsed.length===0){ processed++; setProgress(processed/keys.length*100); continue; }

      const minDt = new Date(Math.min(...parsed.map(p=>p.dt.getTime())));
      const batchDate = new Date(minDt);
      if(batchDate.getHours() < 19) batchDate.setDate(batchDate.getDate()-1);
      batchDate.setHours(0,0,0,0);

      if(batchDate >= startDate && batchDate <= endDate){
        const k = batchDate.toISOString().slice(0,10);
        if(!dateGroups[k]) dateGroups[k] = {};
        dateGroups[k][batchKey] = parsed;
        sheetDates[k] = batchDate;
      }

      processed++;
      setProgress(Math.floor(processed/keys.length*100));
    }

    const allDates = Object.keys(dateGroups).sort();
    if(allDates.length===0) throw 'No rows matched the date range';

    processedWB = XLSX.utils.book_new();
    storedSheets = {};

    const batchCounts = {};
    const index14Counts = {};
    const forceCols=[1,18,19,20,31,32,33];

    let si = 0;
    for(const dateKey of allDates){

      const batches = dateGroups[dateKey];
      const sortedBatchKeys = Object.keys(batches)
        .map(bk=>({ bk, min:Math.min(...batches[bk].map(x=>x.dt.getTime())) }))
        .sort((a,b)=>a.min-b.min)
        .map(x=>x.bk);

      let allRows = [];
      for(const bk of sortedBatchKeys){
        allRows.push([`BATCH: ${bk}`]);
        let sorted = batches[bk].slice().sort((a,b)=>a.dt-b.dt);
        for(let e of sorted){
          let rc = e.row.slice();
          for(let ci of forceCols) rc[ci] = forceDateText(rc[ci]);
          if(rc[20]){
            const d=parseU(rc[20]);
            if(d) rc[20]=formatTextDate(d);
          }
          allRows.push(rc);
        }
      }

      const finalData = headers.concat(allRows);
      const wsOut = XLSX.utils.aoa_to_sheet(finalData);
      const sheetName = makeSheetNameFromDate(sheetDates[dateKey]);
      XLSX.utils.book_append_sheet(processedWB, wsOut, sheetName);

      storedSheets[sheetName] = XLSX.utils.sheet_to_json(wsOut,{header:1,defval:''});

      const aoa = storedSheets[sheetName];
      const exportedBody = aoa.slice(5);

      const uniq = new Set();
      let idx14 = 0;

      exportedBody.forEach(r=>{
        const b=(r[16]??'').toString().trim();
        const i14=(r[13]??'').toString().trim();
        if(b) uniq.add(b);
        if(i14) idx14++;
      });

      batchCounts[sheetName] = uniq.size;
      index14Counts[sheetName] = idx14;

      si++;
      setProgress(Math.floor(si/allDates.length*100));
    }

    setLog('Trips / Units:');
    Object.keys(batchCounts).sort().forEach(sn=>{
      logEl.innerHTML +=
        `\n<span class="logClickable" onclick="showDetails('${sn}')">${sn} = ${batchCounts[sn]} / ${index14Counts[sn]}</span>`;
    });

    document.getElementById('download').disabled=false;
    setProgress(100);
    setLog('\nâœ… DONE. You may now click DOWNLOAD.');
  }
  catch(err){
    setLog('\nâš  ERROR: '+err);
  }
  finally {
    btnRun.disabled=false;
    btnRun.classList.remove('running');
    btnRun.textContent='Run';
  }
});

function showDetails(sheetName){
  const aoa = storedSheets[sheetName];
  if(!aoa) return alert("No sheet data.");
  const body = aoa.slice(5);

  let uniqueQ = [...new Set(body.map(r => (r[16]??'').toString().trim()).filter(x=>x))];
  let results = {};

  uniqueQ.forEach(qVal=>{
    body.forEach(r=>{
      if((r[16]??'').toString().trim() === qVal){
        let dVal = r[3];
        if(!results[dVal]) results[dVal]=0;
      }
    });
  });

  uniqueQ.forEach(qVal=>{
    body.forEach(r=>{
      if((r[16]??'').toString().trim() === qVal){
        let dVal = r[3];
        let colI = r[8];
        if(colI !== "" && colI != null) results[dVal]++;
      }
    });
  });

  let msg = `DETAILS for ${sheetName}\n\n`;
  Object.keys(results).forEach(k=>{
    msg += `${k} = ${results[k]}\n`;
  });

  alert(msg);
}

document.getElementById('download').addEventListener('click', () => {
  if(!processedWB) return alert('Run first.');
  XLSX.writeFile(processedWB,'Export_PerDate_Styled.xlsx');
  setLog('\nðŸ“¦ Export_PerDate_Styled.xlsx saved.');
});
</script>

</body>
</html>
